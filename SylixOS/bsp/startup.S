;/*********************************************************************************************************
;**
;**                                    中国软件开源组织
;**
;**                                   嵌入式实时操作系统
;**
;**                                SylixOS(TM)  LW : long wing
;**
;**                               Copyright All Rights Reserved
;**
;**--------------文件信息--------------------------------------------------------------------------------
;**
;** 文   件   名: startup.S
;**
;** 创   建   人: Jiao.JinXing (焦进星)
;**
;** 文件创建日期: 2018 年 03 月 20 日
;**
;** 描        述: RISC-V 处理器系统启动.
;*********************************************************************************************************/
    
#ifndef ASSEMBLY
#define ASSEMBLY 1
#endif

#include "config.h"
#include <arch/assembler.h>
#include "arch/riscv/arch_regs.h"

    FILE_BEGIN()

;/*********************************************************************************************************
;  声明外部函数和导出全局函数
;*********************************************************************************************************/

    IMPORT_LABEL(bspInit)
    IMPORT_LABEL(bspSecondaryCpuInit)
    IMPORT_LABEL(archTrapEntry)
    EXPORT_LABEL(_G_ulRiscvCpuIdToHartId)

;/*********************************************************************************************************
;  定义
;*********************************************************************************************************/

#define __BOOT_STACK_SIZE    (32 * 1024)
#define __CPUID_MASK         (0xf)
#define __STACK_MASK         (~0xf)

;/*********************************************************************************************************
;  异常向量表(注意: K210进入时为machine mode)
;*********************************************************************************************************/

    SECTION(.vector)

FUNC_DEF(vector)
    J       reset
    .word   0xdeadbeef
    .align  3
    .global g_wake_up
g_wake_up:
    .dword  1
    .dword  0

FUNC_END(vector)

;/*********************************************************************************************************
;  复位入口
;*********************************************************************************************************/

    SECTION(.text)

FUNC_DEF(reset)
    csrw  mideleg, 0
    csrw  medeleg, 0
    csrw  mie, 0
    csrw  mip, 0

;/*********************************************************************************************************
;  初始化寄存器和异常向量表地址
;*********************************************************************************************************/

    LA          T0 , archTrapEntry
    CSRW        XTVEC , T0

    LI          X1  , 0
    LI          X2  , 0
    LI          X3  , 0
    LI          X4  , 0
    LI          X5  , 0
    LI          X6  , 0
    LI          X7  , 0
    LI          X8  , 0
    LI          X9  , 0
#if 0                                                                   /*  A0 A1 作为参数, 跳过清零     */
    LI          X10 , 0
    LI          X11 , 0
#endif
    LI          X12 , 0
    LI          X13 , 0
    LI          X14 , 0
    LI          X15 , 0
    LI          X16 , 0
    LI          X17 , 0
    LI          X18 , 0
    LI          X19 , 0
    LI          X20 , 0
    LI          X21 , 0
    LI          X22 , 0
    LI          X23 , 0
    LI          X24 , 0
    LI          X25 , 0
    LI          X26 , 0
    LI          X27 , 0
    LI          X28 , 0
    LI          X29 , 0
    LI          X30 , 0
    LI          X31 , 0

    .option push
    .option norelax
    LA          GP  , _gp                                               ;/*  初始化 GP 寄存器            */
    .option pop

;/*********************************************************************************************************
;  在这里加入初始化最核心硬件接口 (有 BOOTLOADER 就不需要初始化 SDRAM 与 PLL)
;*********************************************************************************************************/

    CSRR        A0 , mhartid                                            ;/*  读取hartid                  */
    MOVE        A2 , A0

;/*********************************************************************************************************
;  初始化堆栈
;*********************************************************************************************************/

    LI          T0 , __STACK_MASK
    LA          T1 , __stack_end
    AND         T1 , T1 , T0                                            ;/*  强制 16 字节对齐            */

    ADDI        T1 , T1 , -ARCH_REG_CTX_SIZE                            ;/*  预留上下文保存空间          */

    LI          T2 , __BOOT_STACK_SIZE
    MOVE        T0 , A2                                                 ;/*  通过 A2 读出 CPUID          */
1:
    BEQZ        T0 , 2f                                                 ;/*  计算每个核的启动栈空间      */
    SUB         T1 , T1 , T2
    ADDI        T0 , T0 , -1
    J           1b

2:
    MOVE        SP , T1                                                 ;/*  设置核的启动栈空间          */

    CSRW        XSCRATCH , SP                                           ;/*  设置核的异常临时栈空间      */
    REG_S       A2 , CPUID_OFFSET(SP)                                   ;/*  记录 CPUID                  */

    LA          T0 , _G_ulRiscvCpuIdToHartId
    SLL         T1 , A2 , LGREG
    ADD         T0 , T0 , T1
    REG_S       A0 , (T0)                                               ;/*  构建 CPUID -> HARTID 转换表 */

    BNEZ        A2 , __secondaryCpu                                     ;/*  如果是 2nd CPU, 则跳转      */

;/*********************************************************************************************************
;  初始化 SDATA 段
;*********************************************************************************************************/

    ;/*
    ; * SDATA_COPY :  从后向前进行拷贝，先搬移 SDATA 段
    ; * T0 = _etext + (_edata - _data) + (_esdata - _sdata)
    ; * T1 = _esdata - 1
    ; * T2 = _sdata
    ; * Do backward copy from T0 to T1(_esdata), until T1 decrease to T2(_sdata).
    ; */

    LA          T0 , _etext

    LA          T1 , _edata
    LA          T2 , _data
    SUB         T1 , T1 , T2
    ADD         T0 , T0 , T1

    LA          T1 , _esdata
    LA          T2 , _sdata
    SUB         T1 , T1 , T2
    ADD         T0 , T0 , T1

    ADDI        T0 , T0 , -SZREG                                        ;/*  .sdata 段加载时末尾的地址   */

    LA          T1 , _esdata
    ADDI        T1 , T1 , -SZREG                                        ;/*  .sdata 段运行时末尾的地址   */
    LA          T2 , _sdata

1:
    REG_L       T3 , 0(T0)                                              ;/*  do copy while T1 >= T2      */
    REG_S       T3 , 0(T1)
    ADDI        T0 , T0 , -SZREG
    ADDI        T1 , T1 , -SZREG
    BGT         T1 , T2 , 1b
    REG_L       T3 , 0(T0)
    REG_S       T3 , 0(T1)

;/*********************************************************************************************************
;  初始化 DATA 段
;*********************************************************************************************************/

    ;/*
    ; * DATA_COPY : 这里可以优化掉计算 T0 的代码，在上面语句后加一条: ADDI T0 , T0 , -SZREG
    ; * T0 = _etext + (_edata - _data)
    ; * T1 = _edata - 1
    ; * T2 = _data
    ; * Do backward copy from T0 to T1(_edata), until T1 decrease to T2(_data).
    ; */

    LA          T0 , _etext

    LA          T1 , _edata
    LA          T2 , _data
    SUB         T1 , T1 , T2
    ADD         T0 , T0 , T1

    ADDI        T0 , T0 , -SZREG                                        ;/*  .data 段加载时末尾的地址    */

    LA          T1 , _edata
    ADDI        T1 , T1 , -SZREG                                        ;/*  .data 段运行时末尾的地址    */
    LA          T2 , _data

1:
    REG_L       T3 , 0(T0)                                              ;/*   do copy when T1 >= T2      */
    REG_S       T3 , 0(T1)
    ADDI        T0 , T0 , -SZREG
    ADDI        T1 , T1 , -SZREG
    BGT         T1 , T2 , 1b
    REG_L       T3 , 0(T0)
    REG_S       T3 , 0(T1)

;/*********************************************************************************************************
;  清零 BSS 段
;*********************************************************************************************************/

    LA          T1 , __bss_start
    LA          T2 , __bss_end

1:
    REG_S       ZERO , 0(T1)
    ADDI        T1 , T1 , SZREG
    BLT         T1 , T2 , 1b

;/*********************************************************************************************************
;  清零 SBSS 段
;*********************************************************************************************************/

    LA          T1 , __sbss_start
    LA          T2 , __sbss_end

1:
    REG_S       ZERO , 0(T1)
    ADDI        T1 , T1 , SZREG
    BLT         T1 , T2 , 1b

;/*********************************************************************************************************
;  进入 bspInit 函数 (MHARTID, DTB)
;*********************************************************************************************************/

    MOVE        FP , SP
    CALL        bspInit

;/*********************************************************************************************************
;  Secondary Cpu 进入 bspSecondaryCpuInit 函数 (MHARTID, DTB)
;*********************************************************************************************************/

LINE_LABEL(__secondaryCpu)
    MOVE        FP , SP
    J           .

FUNC_END(reset)

;/*********************************************************************************************************
;  CPUID 彩票
;*********************************************************************************************************/

    SECTION(.noinit)
    .align      6
LINE_LABEL(_G_ulCpuIdIottery)
    .space      8

;/*********************************************************************************************************
;  CPUID -> HARTID 转换表
;*********************************************************************************************************/

LINE_LABEL(_G_ulRiscvCpuIdToHartId)
    .space      512

    FILE_END()

;/*********************************************************************************************************
;  END
;*********************************************************************************************************/
